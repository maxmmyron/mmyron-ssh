package main

import (
	// "context"
	// "errors"
	"fmt"
	// "net"
	"os"
	// "os/signal"
	"strings"
	// "syscall"
	// "time"

	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"

	// "github.com/charmbracelet/log"
	"github.com/charmbracelet/ssh"
	// "github.com/charmbracelet/wish"
	// "github.com/charmbracelet/wish/activeterm"
	// "github.com/charmbracelet/wish/bubbletea"
	// "github.com/charmbracelet/wish/logging"
)

var (
	titleStyle = func() lipgloss.Style {
		b := lipgloss.RoundedBorder()
		b.Right = "├"
		return lipgloss.NewStyle().BorderStyle(b).Padding(0, 1)
	}()

	infoStyle = func() lipgloss.Style {
		b := lipgloss.RoundedBorder()
		b.Left = "┤"
		return titleStyle.Copy().BorderStyle(b)
	}()
)

const (
	useHighPerformanceRenderer = false
	host                       = "localhost"
	port                       = "23234"
)

// this model type will store the state of our app
type model struct {
	url      string
	content  string
	viewport viewport.Model
	ready    bool
}

func main() {
	// Load some text for our viewport
	content, err := os.ReadFile("fs/root.md")
	if err != nil {
		fmt.Println("could not load file:", err)
		os.Exit(1)
	}

	p := tea.NewProgram(
		model{content: string(content)},
		tea.WithAltScreen(),       // use the full size of the terminal in its "alternate screen buffer"
		tea.WithMouseCellMotion(), // turn on mouse support so we can track the mouse wheel
	)

	if _, err := p.Run(); err != nil {
		fmt.Println("could not run program:", err)
		os.Exit(1)
	}
}

// func main() {
// 	srv, err := wish.NewServer(
// 		wish.WithAddress(net.JoinHostPort(host, port)),
// 		// ED25519 key generated by default
// 		wish.WithHostKeyPath(".ssh/id_ed25519"),
// 		wish.WithMiddleware(
// 			bubbletea.Middleware(teaHandler),
// 			activeterm.Middleware(),
// 			logging.Middleware(),
// 		),
// 	)

// 	if err != nil {
// 		log.Error("Couldn't start server", err)
// 	}

// 	done := make(chan os.Signal, 1)
// 	signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
// 	log.Info("Server started @", "host", host, "port", port)

// 	// TODO: what does this do? similar to IIFE in JS?
// 	go func() {
// 		if err = srv.ListenAndServe(); err != nil && !errors.Is(err, ssh.ErrServerClosed) {
// 			log.Error("Could not start server", err)
// 			done <- nil
// 		}
// 	}()

// 	// TODO: what does this do?
// 	<-done

// 	log.Info("Shutting down server...")
// 	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)

// 	defer func() { cancel() }()

// 	if err := srv.Shutdown(ctx); err != nil && !errors.Is(err, ssh.ErrServerClosed) {
// 		log.Error("Could not shutdown server", err)
// 	}
// }

func teaHandler(s ssh.Session) (tea.Model, []tea.ProgramOption) {
	// use Fileread
	content, err := os.ReadFile("fs/root.md")

	if err != nil {
		fmt.Println("Error reading file:", err)
		return model{}, nil
	}

	fmt.Println("Content:", string(content))

	m := model{
		content: string(content),
		url:     "root",
		ready:   false,
	}

	return m, []tea.ProgramOption{tea.WithAltScreen(), tea.WithMouseCellMotion()}
}

func (m model) Init() tea.Cmd {
	return nil
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var (
		cmd  tea.Cmd
		cmds []tea.Cmd
	)

	switch msg := msg.(type) {

	case tea.WindowSizeMsg:
		fmt.Println("windowsize msg")
		headerHeight := lipgloss.Height(m.headerView())
		footerHeight := lipgloss.Height(m.footerView())
		verticalMarginHeight := headerHeight + footerHeight

		if !m.ready {
			// Since this program is using the full size of the viewport we
			// need to wait until we've received the window dimensions before
			// we can initialize the viewport. The initial dimensions come in
			// quickly, though asynchronously, which is why we wait for them
			// here.
			m.viewport = viewport.New(msg.Width, msg.Height-verticalMarginHeight)
			m.viewport.YPosition = headerHeight
			m.viewport.HighPerformanceRendering = useHighPerformanceRenderer
			m.viewport.SetContent(m.content)
			m.ready = true

			// This is only necessary for high performance rendering, which in
			// most cases you won't need.
			//
			// Render the viewport one line below the header.
			m.viewport.YPosition = headerHeight + 1
		} else {
			m.viewport.Width = msg.Width
			m.viewport.Height = msg.Height - verticalMarginHeight
		}

		if useHighPerformanceRenderer {
			cmds = append(cmds, viewport.Sync(m.viewport))
		}
	case tea.KeyMsg:
		switch msg.String() {
		case "q", "ctrl+c":
			return m, tea.Quit
		}
	}

	m.viewport, cmd = m.viewport.Update(msg)
	cmds = append(cmds, cmd)

	return m, tea.Batch(cmds...)
}

func (m model) View() string {
	if !m.ready {
		return "\n Loading..."
	}

	// out, err := glamour.Render(m.viewport.View(), "dark")

	// if err != nil {
	// 	return fmt.Sprintf("Error rendering markdown: %v", err)
	// }

	return fmt.Sprintf("%s\n%s\n%s", m.headerView(), m.viewport.View(), m.footerView())
}

func (m model) headerView() string {
	title := titleStyle.Render("/")
	line := strings.Repeat("─", max(0, m.viewport.Width-lipgloss.Width(title)))
	return lipgloss.JoinHorizontal(lipgloss.Center, title, line)
}

func (m model) footerView() string {
	info := infoStyle.Render(fmt.Sprintf("%3.f%%", m.viewport.ScrollPercent()*100))
	line := strings.Repeat("─", max(0, m.viewport.Width-lipgloss.Width(info)))
	return lipgloss.JoinHorizontal(lipgloss.Center, line, info)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
