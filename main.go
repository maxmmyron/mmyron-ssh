package main

import (
	"context"
	"errors"
	"fmt"
	"net"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/charmbracelet/bubbles/list"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/glamour"
	"github.com/charmbracelet/lipgloss"
	"github.com/charmbracelet/lipgloss/table"
	"github.com/charmbracelet/log"
	"github.com/charmbracelet/ssh"
	"github.com/charmbracelet/wish"
	"github.com/charmbracelet/wish/activeterm"
	"github.com/charmbracelet/wish/bubbletea"
	"github.com/charmbracelet/wish/logging"
	"golang.org/x/term"
)

type post struct {
	title, path, desc string
}

func (p post) Title() string       { return p.title }
func (p post) Path() string        { return p.path }
func (p post) Description() string { return p.desc }
func (p post) FilterValue() string { return p.title }

const (
	headerHeight               = 5
	footerHeight               = 5
	useHighPerformanceRenderer = false
	host                       = "localhost"
	port                       = "23234"
	glamourMaxWidth            = 78
	viewportMaxWidth           = 80
)

var (
	loaded           = false
	ApplyNormal      = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#000", Dark: "#D7D7D7"}).Render
	ApplySubtle      = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#666", Dark: "#7C7C7C"}).Render
	ApplyMuted       = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#666", Dark: "#3F3F3F"}).Render
	ApplyHighlight   = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#000", Dark: "#F93EFD"}).Render
	tableBorderColor = lipgloss.AdaptiveColor{Light: "#cccccc", Dark: "#3F3F3F"}
	posts            = []list.Item{
		post{title: "Improving gradients in TailwindCSS", path: "/posts/gradients", desc: "An unnecessarily deep dive into improving a teeny subset of TailwindCSS's utility classes."},
		post{title: "Post 2", path: "/posts/2", desc: "2021-01-02"},
		post{title: "Post 3", path: "/posts/3", desc: "2021-01-03"},
	}
)

func main() {
	// set glamour env
	os.Setenv("GLAMOUR_STYLE", "./style.json")

	// set up a new wish server. This allows us to serve a terminal UI over SSH
	srv, err := wish.NewServer(
		wish.WithAddress(net.JoinHostPort(host, port)),
		// ED25519 key generated by default
		wish.WithHostKeyPath(".ssh/id_ed25519"),
		wish.WithMiddleware(
			bubbletea.Middleware(teaHandler),
			activeterm.Middleware(),
			logging.Middleware(),
		),
	)

	if err != nil {
		log.Error("Couldn't start server", err)
	}

	// allocate a channel for signals, and forward Interrupt, SIGINT and SIGTERM signals to it
	done := make(chan os.Signal, 1)
	signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

	log.Info("Server started @", "host", host, "port", port)

	// this goroutine listens for incoming connections in a concurrent fashion during server startup
	go func() {
		if err = srv.ListenAndServe(); err != nil && !errors.Is(err, ssh.ErrServerClosed) {
			log.Error("Could not start server", err)
			// if there's an error with starting the server, send a signal to the done channel
			done <- nil
		}
	}()

	// by default this blocks flow until a signal is received.
	// a signal is received when (1.) we receive an interrupt signal of some kind, or (2.) the server is closed
	// we're done with the channel once we receive a signal, so the <- into nothing will discard the signal
	<-done

	// we've received a signal, so we need to shut down the server
	// TODO: add docs for this... why ctx all the way down here?
	log.Info("Shutting down server...")
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)

	// right before we exit the main function, cancel the context()
	defer func() { cancel() }()

	if err := srv.Shutdown(ctx); err != nil && !errors.Is(err, ssh.ErrServerClosed) {
		log.Error("Could not shutdown server", err)
	}
}

// initializes state and returns a new model and bubbletea options
func teaHandler(s ssh.Session) (tea.Model, []tea.ProgramOption) {
	// get the width/height of the viewport for a rough initial size estimate
	physWidth, physHeight, _ := term.GetSize(int(os.Stdout.Fd()))

	computedWidth := min(physWidth, glamourMaxWidth)

	vp := viewport.New(physWidth, physHeight-headerHeight-footerHeight)
	vp.HighPerformanceRendering = useHighPerformanceRenderer

	m := model{
		viewport: vp,
		list:     list.New(posts, list.NewDefaultDelegate(), computedWidth, physHeight-headerHeight),
	}

	loaded = false

	m.list.Title = "Recent Posts"

	// dont use tea.WithMouseCellMotion() because it seems to break the viewport when scrolling fast
	return m, []tea.ProgramOption{tea.WithAltScreen()}
}

type model struct {
	viewport viewport.Model // current viewport
	path     string         // current path we're supposed to be rendering. also used in rendering the header
	content  string         // content to render in the viewport
	list     list.Model
}

// struct method: Init() returns a command to run when the program starts
func (m model) Init() tea.Cmd {
	return nil
}

func UpdatePage(m model, path string) (model, tea.Cmd) {
	if path == "/posts" {
		m.path = path
		// m.viewport.SetYOffset(0)
		m.viewport.SetContent("")
		return m, nil
	}

	fmt.Println("Navigating to", path)
	// if we don't exit early, we've navigated to a new page. We need to read the content and rebuild the glamour viewport
	content, err := os.ReadFile("fs" + path + ".md")

	if err != nil {
		fmt.Println("Could not read content:", err)
		return m, nil
	}

	fmt.Println("gooda")
	m.path = path
	m.content = string(content)
	m.viewport.SetYOffset(0)

	width := min(m.viewport.Width, glamourMaxWidth)

	// render content to dynamic size
	renderer, err := glamour.NewTermRenderer(
		glamour.WithEnvironmentConfig(),
		glamour.WithWordWrap(width),
	)

	if err != nil {
		return m, nil
	}

	fmt.Println("goodb")

	str, err := renderer.Render(m.content)

	if err != nil {
		return m, nil
	}

	fmt.Println("goodc")

	m.viewport.SetContent(lipgloss.Place(m.viewport.Width, m.viewport.Height, lipgloss.Center, lipgloss.Top, str))

	return m, nil
}

// struct method: Update() returns a new model and command to run based on the message received
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var (
		cmd  tea.Cmd
		cmds []tea.Cmd
	)

	switch msg := msg.(type) {
	// handle window resize
	case tea.WindowSizeMsg:
		m.viewport.Width = msg.Width
		m.viewport.Height = msg.Height - headerHeight - footerHeight + 1
		m.viewport.YPosition = headerHeight
		m.viewport.Style = lipgloss.NewStyle().Width(m.viewport.Width).Height(m.viewport.Height)

		m.list.SetWidth(m.viewport.Width)
		m.list.SetHeight(msg.Height - headerHeight - 2) // account for extra newlines in View()

		// if we haven't full loaded yet, then we need to load page content
		if !loaded {
			m, _ = UpdatePage(m, "/root")
			loaded = true
		}

		// in high rendering mode, we need to resync the viewport (akin to rerender)
		if useHighPerformanceRenderer {
			cmds = append(cmds, viewport.Sync(m.viewport))
		}
	case tea.KeyMsg:
		switch msg.String() {
		case "b":
			if m.path == "/root" {
				// if we're already at root, then do nothing
				return m, nil
			}

			if m.path == "/posts" {
				m, _ = UpdatePage(m, "/root")
			} else {
				m, _ = UpdatePage(m, "/posts")
			}
		case "p":
			if m.path == "/posts" {
				// if we're already at posts, then do nothing
				return m, nil
			}
			m, _ = UpdatePage(m, "/posts")
		case "enter":
			if m.path == "/posts" {
				// if we're at the posts page, then we need to navigate to the selected post
				selected := m.list.SelectedItem()
				if selected == nil {
					return m, nil
				}
				m, _ = UpdatePage(m, selected.(post).Path())
			}
		case "q", "ctrl+c":
			return m, tea.Quit
		}
	}

	// handle default keyboard/mouse events for viewport/list, depending on route
	if m.path != "/posts" {
		m.viewport, cmd = m.viewport.Update(msg)
	} else {
		m.list, cmd = m.list.Update(msg)
	}

	cmds = append(cmds, cmd)
	return m, tea.Batch(cmds...)
}

func (m model) View() string {
	fmt.Println("Updating render for", m.path)
	var view string
	switch m.path {
	case "/posts":
		view = "\n" + ListView(m)
	default:
		view = m.viewport.View() + HelpView(m)
	}

	return HeaderView(m) + view
}

// center the list
func ListView(m model) string {
	maxWidth := min(m.viewport.Width, viewportMaxWidth+2)

	listContainer := lipgloss.NewStyle().Width(maxWidth).AlignHorizontal(lipgloss.Left).SetString(m.list.View())
	listView := lipgloss.NewStyle().Width(m.viewport.Width).AlignHorizontal(lipgloss.Center).SetString(listContainer.Render())
	return listView.Render()
}

// builds out the header, which is shown on all pages
func HeaderView(m model) string {
	const (
		altLinkWidth = 11
		linkPadding  = 2
	)

	// build out text
	content := m.path
	sideContent := fmt.Sprintf("%s %s", ApplyHighlight("p"), ApplySubtle("posts"))
	if content != "/root" {
		sideContent = fmt.Sprintf("%s %s", ApplyHighlight("b"), ApplySubtle("back"))
	} else {
		content = "/"
	}
	content = ApplyNormal("mmyron.com" + content)

	// calculate widths for main content
	maxWidth := min(m.viewport.Width, viewportMaxWidth)
	mainWidth := maxWidth - altLinkWidth
	mainContentWidth := mainWidth - 2 - 2*linkPadding // 2 for the border, 4 for the padding

	// truncate if necessary
	if len(content) > mainContentWidth {
		content = content[:mainContentWidth-4] + "..."
	}

	var (
		pathStyle = lipgloss.NewStyle().Width(mainContentWidth).Padding(0, linkPadding).Render
		altStyle  = lipgloss.NewStyle().Width(altLinkWidth).Padding(0, linkPadding).Render
	)

	t := table.New().BorderColumn(true).Width(maxWidth).Border(lipgloss.NormalBorder()).BorderStyle(lipgloss.NewStyle().Foreground(tableBorderColor))
	t.Row(pathStyle(content), altStyle(sideContent))

	container := lipgloss.NewStyle().Width(m.viewport.Width).Height(headerHeight).Align(lipgloss.Center, lipgloss.Center).SetString(t.Render()).Render()

	return container
}

func HelpView(m model) string {
	// ▲/▼ scroll  •  q quit
	scrollHelp := fmt.Sprintf("%s %s", ApplyHighlight("▲/▼"), ApplySubtle("scroll"))
	quitHelp := fmt.Sprintf("%s %s", ApplyHighlight("q"), ApplySubtle("quit"))
	help := fmt.Sprintf("%s  %s  %s", scrollHelp, ApplyMuted("•"), quitHelp)

	maxWidth := min(m.viewport.Width, viewportMaxWidth)

	helpSection := lipgloss.NewStyle().
		Width(maxWidth).Height(2).
		Border(lipgloss.NormalBorder(), true, false, false).BorderForeground(tableBorderColor).
		Align(lipgloss.Center, lipgloss.Bottom).
		SetString(help).Render()

	container := lipgloss.Place(m.viewport.Width, 4, lipgloss.Center, lipgloss.Bottom, helpSection)

	return container
}
