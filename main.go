package main

import (
	"context"
	"errors"
	"fmt"
	"net"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/charmbracelet/bubbles/list"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/glamour"
	"github.com/charmbracelet/lipgloss"
	"github.com/charmbracelet/lipgloss/table"
	"github.com/charmbracelet/log"
	"github.com/charmbracelet/ssh"
	"github.com/charmbracelet/wish"
	"github.com/charmbracelet/wish/activeterm"
	"github.com/charmbracelet/wish/bubbletea"
	"github.com/charmbracelet/wish/logging"
	"golang.org/x/term"
)

type post struct {
	title, path, desc string
}

func (p post) Title() string       { return p.title }
func (p post) Path() string        { return p.path }
func (p post) Description() string { return p.desc }
func (p post) FilterValue() string { return p.title }

const (
	headerHeight               = 4
	footerHeight               = 2
	useHighPerformanceRenderer = false
	host                       = "localhost"
	port                       = "23234"
	glamourMaxWidth            = 78
	viewportMaxWidth           = 80
)

var (
	ApplyNormal      = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#000", Dark: "#D7D7D7"}).Render
	ApplySubtle      = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#666", Dark: "#7C7C7C"}).Render
	ApplyHighlight   = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#000", Dark: "#F93EFD"}).Render
	tableBorderColor = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#cccccc", Dark: "#3F3F3F"})
	posts            = []list.Item{
		post{title: "Post 1", path: "/posts/1", desc: "2021-01-01"},
		post{title: "Post 2", path: "/posts/2", desc: "2021-01-02"},
		post{title: "Post 3", path: "/posts/3", desc: "2021-01-03"},
	}
)

func main() {
	// set glamour env
	os.Setenv("GLAMOUR_STYLE", "./style.json")

	// set up a new wish server. This allows us to serve a terminal UI over SSH
	srv, err := wish.NewServer(
		wish.WithAddress(net.JoinHostPort(host, port)),
		// ED25519 key generated by default
		wish.WithHostKeyPath(".ssh/id_ed25519"),
		wish.WithMiddleware(
			bubbletea.Middleware(teaHandler),
			activeterm.Middleware(),
			logging.Middleware(),
		),
	)

	if err != nil {
		log.Error("Couldn't start server", err)
	}

	// allocate a channel for signals, and forward Interrupt, SIGINT and SIGTERM signals to it
	done := make(chan os.Signal, 1)
	signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

	log.Info("Server started @", "host", host, "port", port)

	// this goroutine listens for incoming connections in a concurrent fashion during server startup
	go func() {
		if err = srv.ListenAndServe(); err != nil && !errors.Is(err, ssh.ErrServerClosed) {
			log.Error("Could not start server", err)
			// if there's an error with starting the server, send a signal to the done channel
			done <- nil
		}
	}()

	// by default this blocks flow until a signal is received.
	// a signal is received when (1.) we receive an interrupt signal of some kind, or (2.) the server is closed
	// we're done with the channel once we receive a signal, so the <- into nothing will discard the signal
	<-done

	// we've received a signal, so we need to shut down the server
	// TODO: add docs for this... why ctx all the way down here?
	log.Info("Shutting down server...")
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)

	// right before we exit the main function, cancel the context()
	defer func() { cancel() }()

	if err := srv.Shutdown(ctx); err != nil && !errors.Is(err, ssh.ErrServerClosed) {
		log.Error("Could not shutdown server", err)
	}
}

// initializes state and returns a new model and bubbletea options
func teaHandler(s ssh.Session) (tea.Model, []tea.ProgramOption) {
	// get the width/height of the viewport for a rough initial size estimate
	physWidth, physHeight, _ := term.GetSize(int(os.Stdout.Fd()))

	computedWidth := min(physWidth, glamourMaxWidth)

	vp := viewport.New(physWidth, physHeight-headerHeight-footerHeight)

	// get root page content
	content, err := os.ReadFile("fs/root.md")

	if err != nil {
		fmt.Println("Could not read root content:", err)
	}

	m := model{
		viewport: vp,
		path:     "/root",
		content:  string(content),
		list:     list.New(posts, list.NewDefaultDelegate(), computedWidth, physHeight-headerHeight),
	}

	m.list.Title = "Recent Posts"

	return m, []tea.ProgramOption{tea.WithAltScreen(), tea.WithMouseCellMotion()}
}

type model struct {
	viewport viewport.Model // current viewport
	path     string         // current path we're supposed to be rendering. also used in rendering the header
	content  string         // content to render in the viewport
	list     list.Model
}

// struct method: Init() returns a command to run when the program starts
func (m model) Init() tea.Cmd {
	return nil
}

// grabs a page's content
func ReadPageContent(path string) (string, error) {
	// if we're at the posts page, return early
	if path == "/posts" {
		return "", nil
	}

	content, err := os.ReadFile("fs" + path + ".md")

	if err != nil {
		return "", err
	}

	return string(content), nil
}

// This rebuilds the glamour viewport with the new content. This mainly runs in two cases:
//  1. when the user navigates to a new page and we need to update the glamour viewport with new content
//  2. when the user selects a new option from the list of paths
//     TODO: case 2 probably doesn't require renderer to be rebuilt, so optimize this in future
func RebuildGlamourViewport(m model) (model, error) {
	// NOTE: it seems like glamour adds like 2ch of padding on each side, so we account for that here.
	width := min(m.viewport.Width, glamourMaxWidth)

	// render content to dynamic size
	renderer, err := glamour.NewTermRenderer(
		glamour.WithEnvironmentConfig(),
		glamour.WithWordWrap(width),
	)

	if err != nil {
		return m, nil
	}

	str, err := renderer.Render(m.content)

	if err != nil {
		return m, nil
	}

	// if posts, return early.
	if m.path == "/posts" {
		return m, nil
	}

	m.viewport.SetContent(lipgloss.Place(m.viewport.Width, m.viewport.Height, lipgloss.Center, lipgloss.Top, str))

	return m, nil
}

// struct method: Update() returns a new model and command to run based on the message received
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	// handle window resize
	case tea.WindowSizeMsg:
		m.viewport.Width = msg.Width
		m.viewport.Height = msg.Height - headerHeight - footerHeight
		m.viewport.Style = lipgloss.NewStyle().Width(m.viewport.Width).Height(m.viewport.Height)

		m.list.SetWidth(m.viewport.Width)
		m.list.SetHeight(msg.Height - headerHeight - 1) // account for extra newlines in View()

	// handle key presses
	case tea.KeyMsg:
		switch msg.String() {
		case "b":
			if m.path == "/root" {
				// if we're already at root, then do nothing
				return m, nil
			}

			if m.path == "/posts" {
				// if we're at the posts page, then we need to navigate back to root
				m.path = "/root"
			} else {
				// if we're at a post, then we need to navigate back to posts
				m.path = "/posts"
			}
		case "p":
			if m.path == "/posts" {
				// if we're already at posts, then do nothing
				return m, nil
			}
			m.path = "/posts"
		case "enter":
			if m.path == "/posts" {
				// if we're at the posts page, then we need to navigate to the selected post
				selected := m.list.SelectedItem()
				if selected == nil {
					return m, nil
				}
				m.path = selected.(post).Path()
			}
		case "q", "ctrl+c":
			return m, tea.Quit
		default:
			var cmd tea.Cmd
			if m.path != "/posts" {
				m.viewport, cmd = m.viewport.Update(msg)
			} else {
				m.list, cmd = m.list.Update(msg)
			}
			return m, cmd
		}
	default:
		return m, nil
	}

	// if we don't exit early, we've navigated to a new page. We need to read the content and rebuild the glamour viewport
	content, err := ReadPageContent(m.path)

	if err != nil {
		fmt.Println("Could not read content:", err)
		return m, nil
	}

	m.content = content
	m.viewport.SetYOffset(0)

	m, err = RebuildGlamourViewport(m)

	if err != nil {
		fmt.Println("Could not rerender content:", err)
		return m, nil
	}

	return m, nil
}

func (m model) View() string {
	if m.path == "/posts" {
		return HeaderView(m) + "\n" + ListView(m)
	}
	return HeaderView(m) + m.viewport.View() + helpView(m)
}

// center the list
func ListView(m model) string {
	maxWidth := min(m.viewport.Width, glamourMaxWidth-2)

	listContainer := lipgloss.NewStyle().Width(maxWidth).AlignHorizontal(lipgloss.Left).SetString(m.list.View())
	listView := lipgloss.NewStyle().Width(m.viewport.Width).AlignHorizontal(lipgloss.Center).SetString(listContainer.Render())
	return listView.Render()
}

// builds out the header, which is shown on all pages
func HeaderView(m model) string {
	const (
		altLinkWidth = 11
		linkPadding  = 2
	)

	// build out text
	content := m.path
	sideContent := fmt.Sprintf("%s %s", ApplyHighlight("p"), ApplySubtle("posts"))
	if content != "/root" {
		sideContent = fmt.Sprintf("%s %s", ApplyHighlight("b"), ApplySubtle("back"))
	} else {
		content = "/"
	}
	content = ApplyNormal("mmyron.com" + content)

	// calculate widths for main content
	maxWidth := min(m.viewport.Width, viewportMaxWidth)
	mainWidth := maxWidth - altLinkWidth
	mainContentWidth := mainWidth - 2 - 2*linkPadding // 2 for the border, 4 for the padding

	// truncate if necessary
	if len(content) > mainContentWidth {
		content = content[:mainContentWidth-4] + "..."
	}

	var (
		pathStyle = lipgloss.NewStyle().Width(mainContentWidth).Padding(0, linkPadding).Render
		altStyle  = lipgloss.NewStyle().Width(altLinkWidth).Padding(0, linkPadding).Render
	)

	t := table.New().BorderColumn(true).Width(maxWidth).Border(lipgloss.NormalBorder()).BorderStyle(tableBorderColor)
	t.Row(pathStyle(content), altStyle(sideContent))

	return lipgloss.NewStyle().Width(m.viewport.Width).Height(5).Align(lipgloss.Center, lipgloss.Center).SetString(t.Render()).Render()
}

func helpView(m model) string {
	help := `↑/↓ scroll • q quit`
	container := lipgloss.NewStyle().
		Width(m.viewport.Width).Height(3).
		Foreground(lipgloss.Color("#666")).
		AlignHorizontal(lipgloss.Center).AlignVertical(lipgloss.Bottom).
		SetString(help)

	return container.Render()
}
